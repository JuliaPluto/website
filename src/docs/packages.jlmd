---
title: "ðŸ“¦ Packages"
tags: ["docs", "reproducibility"]
layout: "md.jlmd"
---

# Pluto's built-in _package management_

Starting with version 0.15, Pluto has a _built-in_ package manager, which means:
1. ðŸŽˆ Packages are **automatically installed** when you use `import` or `using`.
2. ðŸŽˆ Your package environment is **stored inside the notebook file**. When someone else opens your notebook with Pluto, the exact same package environment will be used, and packages will work on their computer.

> ðŸ™‹ These two features are designed to make it easy to write and share **reproducible notebooks**.

<br>
<br>
<br>

# Basic usage

## Installing and using packages

Pluto will automatically install or remove packages while you work on your notebook. When you import a new package, Pluto will install it:

<img width="541" alt="Schermafbeelding 2021-06-10 om 20 35 52" src="https://user-images.githubusercontent.com/6933510/121580636-45e66c00-ca2d-11eb-97e2-351068d58057.png">




> ðŸ™‹ Most packages will write _installation instructions_ in their documentation: like "Run `julia> ] install Example` to install `Example`". If you are using Pluto, you can skip these instructions, and import the package directly, using `import Example` or `using Example`.

#### Logs

Installing packages can take some time, especially when starting Julia for the first time. Click on the status mark next to a package to view the installation progress. You can click on the <img src="https://cdn.jsdelivr.net/gh/ionic-team/ionicons@5.5.1/src/svg/document-text-outline.svg" alt="ðŸ“„" width=17px> icon to view the logs.

<img width="541" src="https://media.giphy.com/media/EMv3miTVQPsVspplgY/giphy.gif">


<br>
<br>


## Removing packages

When you delete the code that imports a package, it will be uninstalled from the package environment. It is _recommended_ to restart the notebook process afterwards to get a fresh start.

<img width="541" src="https://media.giphy.com/media/dIFYIHZ2zBFrFDCodM/giphy.gif">

<br>
<br>


## Updating packages

You can search for and install any available updates by clicking on the <img src="https://cdn.jsdelivr.net/gh/ionic-team/ionicons@5.5.1/src/svg/arrow-up-circle-outline.svg" alt="ðŸ“„" width=17px> icon. A backup of your notebook file will be created in the same folder as your notebook, in case the new versions do not work as expected.

<img width="541" alt="Update button" src="https://user-images.githubusercontent.com/6933510/121583646-d1adc780-ca30-11eb-9741-fc9529756061.png">

<br>
<br>
<br>
<br>
<br>
<br>
<br>


# Good to know

### Based on Pkg

Pluto's package management is a wrapper around [Pkg.jl](https://pkgdocs.julialang.org/v1/), Julia's built-in package manager. Packages are installed from the [General registry](https://github.com/JuliaRegistries/General). 

> ðŸ™‹ You can discover all available packages on [juliahub.com](https://juliahub.com/ui/Home).

### Isolated package environment

Every notebook runs in its own isolated package environment. This ensures that your notebook code will not be influenced by packages installed elsewhere. (The `LOAD_PATH` is set to `["@", "@stdlib"]`.)

### Notebook file

Pluto stores the contents of [`Project.toml` and `Manifest.toml`](https://pkgdocs.julialang.org/v1/toml-files/) directly in the notebook file. For forwards-backwards compatibility, this is done using two extra "cells" at the bottom of the file, containing the two files as string literals. For example, here is a notebook that imports `HypertextLiteral` and `PlutoUI`: [`fonsp/Pluto file format demo.jl`](https://gist.github.com/fonsp/44e72741cefb6041506cb8c7040db1a7).

> ðŸ™‹ We encourage you to open Pluto, import some packages and look at the file!

### Fully reproducible environments

When someone else opens your notebook for the first time, Pluto will install all required packages based on the information in the [`Manifest.toml`](https://pkgdocs.julialang.org/v1/toml-files/#Manifest.toml) file. This means that the exact same versions of all packages you used in the notebook will be installed, ensuring your work is fully reproducible when shared with others.

### Compatibility across Pluto versions

When opening an old Pluto notebook that does not have embedded project files, Pluto will generate them as if you typed those imports for the first time. If a call to `Pkg.activate` is made, the notebook will run in 'backwards compatibility mode', using the same environment and behaviour as old Pluto versions.

### Compatibility across Julia versions

The `Manifest.toml` is designed to be (generally) _backwards compatible_: you can upgrade Julia and use an old manifest. However, the `Manifest.toml` is not always _forwards compatible_: a manifest generated generated with a newer version of Julia might not run on older versions. 

Pluto will always try to load the embedded manifest, and if it fails, it will _discard the manifest_ (leaving only `Project.toml`) and try again. This is one reason why Pluto automatically adds `[compat]` ranges for each package in the `Project.toml`.

### Package installations are shared between environments

In Julia, packages are always installed globally, while _environments_ (including notebooks) only store **version information**, not the package code itself. This means that multiple notebooks that use the same version of `Plots` will not lead to more disk usage or precompile time. (This is different from `venv` in Python/pip, or `node_modules` in NodeJS/npm, where every environment contains copies of package code by default.) Julia's package manager is designed to work well with many package environments on the same computer.

Of course, if different notebooks use different version of the same package, and you work on both in parallel, then source files for both versions will exist on your computer. A small price to pay for simpler reproducibility!

In Julia 1.5 and 1.6, you can clean up package files that have not been used in a while using `import Pkg; Pkg.gc()`. In Julia 1.7 and up, this will be done [automatically](https://github.com/JuliaLang/Pkg.jl/pull/2567).

### Custom registries

Pkg.jl supports additional private or public registries, which can be added in the Julia REPL with `] registry add https://github.com/myuser/MyRegistry.git`, and this is also supported by Pluto's package managemer. 

However, note that registries are not stored in the `Project.toml`/`Manifest.toml` files, which means that other people can only open your notebook if they added the custom registry before doing so. Alternatively, you can use a "Pkg cell" (more on this later) where you add the registry before adding packages.

<br>
<br>
<br>
<br>
<br>
<br>
<br>

# Advanced: set up an environment with `Pkg.activate`

Pluto's package manager is enabled for all users, for ease of use and to promote reproducibility in scientific computing. There is no option to disable the behaviour _globally_ (for your entire Pluto session). Instead, Pluto will detect notebooks that use `Pkg.activate` to set up an environment explicitly, and uses the old behaviour for those notebooks.

The philosophy here is that everyone should have a reproducible package environment **by default**, without having to do anything. This takes priority over other use cases, and hence _not_ using the built-in package manager requires some extra work.

<br>


**Any notebook that calls [`Pkg.activate`](https://pkgdocs.julialang.org/v1/api/#Pkg.activate) will not use Pluto's package management,** and run in 'backwards compatibility mode'. The `Pkg.activate` call should be placed directly in your notebook code: it is detecting using the same syntax analysis used for reactivity.

<br>
<br>

## Pattern: The "global environment"
If you do not intend on sharing a notebook file and you want to use your global package environment (called `(v1.6)` or similar, the one you get when you launch the Julia REPL), then you can call `Pkg.activate()` without any arguments.

> ðŸ™‹ If you are developing a package, then activating your global environment is an easy way to test your local version in Pluto.

This "global environment" pattern can be placed at the top of a notebook:

```julia
begin
    import Pkg
    # careful: this is _not_ a reproducible environment
    # activate the global environment
    Pkg.activate()

    using Plots, PlutoUI, LinearAlgebra
end
```


When running this in Pluto (try it out!), you will notice that the status marks next to packages disappear, and Pluto is running in 'backwards compatibility mode'. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself.


<br>
<br>

## Pattern: The "shared environment"
If you have multiple notebooks in a repository and you want to use share a Pkg environment between them, then you can call `Pkg.activate(path_to_environment)`. You can use `@__DIR__` to get the path of the notebook's folder, and `joinpath(@__DIR__, "..")` to get its parent, `joinpath(@__DIR__, "..", "..")` for the parent's parent, etc. 

The function `Base.current_project()` can be used to **automatically** find the closest parent directory that contains a `Project.toml`, in most cases this is what you want.

For example, if your project looks like this:

```
my_project/
    data/
        ...
    notebooks/
        Interesting analysis.jl
        ...
    Project.toml
    Manifest.toml
    ...
```

then the "shared environment" pattern can be placed at the top of a notebook:

```julia
begin
    import Pkg
    # activate the shared project environment
    Pkg.activate(Base.current_project())
    # instantiate, i.e. make sure that all packages are downloaded
    Pkg.instantiate()

    using Plots, PlutoUI, LinearAlgebra
end
```


When running this in Pluto, you will notice that the status marks next to packages disappear, and Pluto is running in 'backwards compatibility mode'. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself.


<br>
<br>

## Pattern: The "Pkg cell"
When adding packages, Pluto's default package management will always install the latest version from the registry. If you need to install a specific version or branch of a package, or a package is not registered, you can use a "Pkg cell".

A common pattern is a so-called "Pkg cell", placed at the top of a notebook:

```julia
begin
    import Pkg
    # activate a temporary environment
    Pkg.activate(mktempdir())
    Pkg.add([
        Pkg.PackageSpec(name="Plots", version="1"),
        Pkg.PackageSpec(name="PlutoUI", version="0.7"),
    ])
    using Plots, PlutoUI, LinearAlgebra
end
```

This will 1) activate a temporary environment using `Pkg.activate`, 2) add the required packages, 3) import them with `using`. When running this in Pluto (try it out!), you will notice that the status marks next to packages disappear, and Pluto is running in 'backwards compatibility mode'. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself.

Placing all code in a single `begin` block ensures that the lines will run in the correct order.

> ðŸ™‹ You can use [this helper tool](https://fonsp.com/article-test-3/pkghelper.html) to generate a "Pkg cell" automatically!










<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>


# Advanced: edit the notebook environment

Pluto.jl includes a helper function `Pluto.activate_notebook_environment` that activates a notebook Pkg environment in the REPL:

```julia
julia> import Pluto

julia> Pluto.activate_notebook_environment("~/Documents/hello.jl")

julia> ]

(hello.jl) > status
```

After activating a notebook environment, you can use the [Pkg REPL](https://pkgdocs.julialang.org/v1/repl/) to view or modify the embedded environment. Changes from either side are synchronised (i.e. Pkg REPL changes are written to the notebook, editing the notebook updates the Pkg REPL env). Watch the demo video:

https://user-images.githubusercontent.com/6933510/111483040-b9c9ee80-8734-11eb-97bc-f51703fc57cc.mov

