[{"url":".","title":"index","tags":["welcome"],"text":""},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict \"en\" Dict \"docs\" \"Introduction\" collections \"docs\" .pages ∩ collections \"introduction\" .pages, \"Reproducibility\" collections \"docs\" .pages ∩ collections \"reproducibility\" .pages, \"Advanced Widgets\" collections \"docs\" .pages ∩ collections \"advanced\" .pages ∩ collections \"widgets\" .pages, \"Advanced Internals\" collections \"docs\" .pages ∩ collections \"advanced\" .pages ∩ collections \"internals\" .pages, , \"examples\" \"Getting started\" collections \"examples\" .pages, , \"blog\" \"Asdfsafd\" collections \"blog\" .pages , "},{"url":"en/blog/something/","title":"Basic syntax","tags":["blog"],"text":" A Pluto.jl notebook v0.18.2 frontmatter title \"Basic syntax\" description \"A simple notebook demonstrating the Julia syntax essentials\" layout \"layout.jlhtml\" date \"2020 06 01\" tags \"blog\" using Markdown using InteractiveUtils md\" Variables We can define a variable using ` ` assignment . Then we can use its value in other expressions \" x 3 y 2x md\"By default Julia displays the output of the last operation. You can suppress the output by adding ` ` a semicolon at the end. \" md\"We can ask what type a variable has using `typeof` \" typeof y md\" Functions\" md\"We can use a short form, one line function definition for simple functions \" f x 2 x md\"Typing the function's name gives information about the function. To call it we must use parentheses \" f f 10 md\"For longer functions we use the following syntax with the `function` keyword and `end` \" function g x, y z x y return z^2 end g 1, 2 md\" For loops\" md\"Use `for` to loop through a pre determined set of values \" let s 0 for i in 1 10 s i Equivalent to s s i end s end md\"Here, `1 10` is a range representing the numbers from 1 to 10 \" typeof 1 10 md\"Above we used a `let` block to define a new local variable `s`. But blocks of code like this are usually better inside functions, so that they can be reused. For example, we could rewrite the above as follows \" function mysum n s 0 for i in 1 n s i end return s end mysum 100 md\" Conditionals `if`\" md\"We can evaluate whether a condition is true or not by simply writing the condition \" a 3 a 5 md\"We see that conditions have a Boolean `true` or `false` value. We can then use `if` to control what we do based on that value \" if a 5 \"small\" else \"big\" end md\"\"\"Note that the `if` also returns the last value that was evaluated, in this case the string `\"small\"` or `\"big\"`, Since Pluto is reactive, changing the definition of `a` above will automatically cause this to be reevaluated \"\"\" md\" Arrays\" md\" 1D arrays `Vector`s \" md\"We can make a `Vector` 1 dimensional, or 1D array using square brackets \" v 1, 2, 3 typeof v md\"The `1` in the type shows that this is a 1D array. We access elements also using square brackets \" v 2 v 2 10 md\"Note that Pluto does not automatically update cells when you modify elements of an array, but the value does change.\" md\"A nice way to create `Vector`s following a certain pattern is to use an array comprehension \" v2 i^2 for i in 1 10 md\" 2D arrays matrices \" md\"We can make small matrices 2D arrays with square brackets too \" M 1 2 3 4 typeof M md\"The `2` in the type confirms that this is a 2D array.\" md\"This won't work for larger matrices, though. For that we can use e.g.\" zeros 5, 5 md\"Note that `zeros` gives `Float64`s by default. We can also specify a type for the elements \" zeros Int, 4, 5 md\"We can then fill in the values we want by manipulating the elements, e.g. with a `for` loop.\" md\"A nice alternative syntax to create matrices following a certain pattern is an array comprehension with a double `for` loop \" i j for i in 1 5, j in 1 6 md\"\"\" Acknowledgement \"\"\" Markdown.MD Markdown.Admonition \"warning\", \"This notebook is taken from\", md\"\"\" Computational Thinking , a live online Julia Pluto textbook. computationalthinking.mit.edu https computationalthinking.mit.edu , original notebook https github.com mitmath 18S191 blob Fall20 lecture notebooks Basic%20Julia%20syntax.jl \"\"\" using PlutoUI TableOfContents "},{"url":"en/blog/yayy/","title":"yayy","tags":["blog"],"text":"Hello there! My name is  fons That's 1 cool That's 2 cool That's 3 cool Want to embed some HTML?  Easy!  Just type the HTML! \\[\\sqrt{\\frac{1}{2}}\\]"},{"url":"en/docs/AbstractPlutoDingetjes/","title":"AbstractPlutoDingetjes.jl – develop enhanced Pluto widgets","tags":["docs","widgets","AbstractPlutoDingetjes","advanced"],"text":" A Pluto.jl notebook v0.19.40 frontmatter image \"https media.giphy.com media l3vRfDn9ca5PVkHv2 giphy.gif\" title \"AbstractPlutoDingetjes.jl – develop enhanced Pluto widgets\" layout \"docsnotebook.jlmd\" tags \"docs\", \"widgets\", \"AbstractPlutoDingetjes\", \"advanced\" date \"2023 11 21\" description \"AbstractPlutoDingetjes allows you to write more advanced widgets to be used inside Pluto.jl.\" license \"Unlicense\" frontmatter.author name \"Pluto.jl\" url \"https github.com JuliaPluto\" using Markdown using InteractiveUtils using AbstractPlutoDingetjes md\"\"\" AbstractPlutoDingetjes.jl \"\"\" Docs.Binding AbstractPlutoDingetjes, AbstractPlutoDingetjes md\"\"\" https media.giphy.com media l3vRfDn9ca5PVkHv2 giphy.gif \"\"\" md\"\"\" AbstractPlutoDingetjes.Bonds \"\"\" Docs.Binding AbstractPlutoDingetjes.Bonds, initial value Docs.Binding AbstractPlutoDingetjes.Bonds, transform value Docs.Binding AbstractPlutoDingetjes.Bonds, possible values Docs.Binding AbstractPlutoDingetjes.Bonds, NotGiven Docs.Binding AbstractPlutoDingetjes.Bonds, InfinitePossibilities Docs.Binding AbstractPlutoDingetjes.Bonds, validate value md\"\"\" AbstractPlutoDingetjes.Display \"\"\" Docs.Binding AbstractPlutoDingetjes.Display, published to js Docs.Binding AbstractPlutoDingetjes.Display, with js link md\"\"\" Extras \"\"\" Docs.Binding AbstractPlutoDingetjes, is supported by display Docs.Binding AbstractPlutoDingetjes, is inside pluto import PlutoUI PlutoUI.TableOfContents include definitions true pkgversion AbstractPlutoDingetjes "},{"url":"en/docs/ExpressionExplorer/","title":"ExpressionExplorer.jl – documentation ","tags":["docs","internals","reactivity","advanced","ExpressionExplorer"],"text":" A Pluto.jl notebook v0.19.41 frontmatter image \"https media.giphy.com media 242BaXJnCfe7hOVrsE giphy.gif\" title \"ExpressionExplorer.jl – documentation \" layout \"docsnotebook.jlmd\" license \"MIT\" description \"Find all variables referenced and assigned in a Julia expression. Used internally by Pluto.jl.\" tags \"docs\", \"internals\", \"reactivity\", \"advanced\", \"ExpressionExplorer\" date \"2023 10 31\" frontmatter.author name \"Pluto.jl\" url \"https github.com JuliaPluto\" using Markdown using InteractiveUtils using PlutoUI TableOfContents using ExpressionExplorer Markdown.parse read joinpath pkgdir ExpressionExplorer , \"README.md\" , String "},{"url":"en/docs/PlutoDependencyExplorer/","title":"PlutoDependencyExplorer.jl – documentation","tags":["docs","PlutoDependencyExplorer","internals","reactivity","ExpressionExplorer","advanced"],"text":" A Pluto.jl notebook v0.19.41 frontmatter image \"https media.giphy.com media 242BaXJnCfe7hOVrsE giphy.gif\" title \"PlutoDependencyExplorer.jl – documentation\" date \"2024 01 21\" license \"Unlicense\" description \"Given a list of cell codes, PlutoDependencyExplorer can tell you in which order these cells should run. Used internally by Pluto.jl.\" tags \"docs\", \"PlutoDependencyExplorer\", \"internals\", \"reactivity\", \"ExpressionExplorer\", \"advanced\" layout \"docsnotebook.jlmd\" frontmatter.author name \"Pluto.jl\" url \"https github.com JuliaPluto\" using Markdown using InteractiveUtils using PlutoDependencyExplorer using PlutoUI TableOfContents include definitions true md\"\"\" PlutoDependencyExplorer.jl \"\"\" Docs.Binding PlutoDependencyExplorer, PlutoDependencyExplorer md\"\"\" Basic example Let's define our \"notebook\", which is just a list of cells \"\"\" const PDE PlutoDependencyExplorer struct SimpleCell PDE.AbstractCell code end notebook SimpleCell. \"x y\" \"x 1\" \"y x 2\" md\"\"\" Next, we want to calculate its toplogy , this is the dependency graph of the notebook all links between cells. \"\"\" empty topology PDE.NotebookTopology SimpleCell topology PDE.updated topology empty topology, notebook, notebook get code str c c.code, get code expr c Meta.parse c.code , md\"\"\" info When reading this notebook, you can click on the data structures in the cells above to expand their tree viewer \"\"\" md\"\"\" Now that we have the topology, we can order cells in the topology. \"\"\" order PDE.topological order topology md\"\"\" The result contains an ordered list of the notebook cells \"\"\" order.runnable md\"\"\" You can also ask PlutoDependencyExplorer which cells should run if one cell re runs. This is a recursive search. For example, if I re run the cell that defines `y` \"\"\" notebook 3 PDE.topological order topology, notebook 3 .runnable md\"\"\" By the way, you can also ask PlutoDependencyExplorer which cell defines `y` \"\"\" PDE.where assigned topology, Set y md\"\"\" Core concepts Let's dig deeper into the Basic example above. The first thing we did was define our own subtype of `PlutoDependencyExplorer.AbstractCell`. \"\"\" Docs.Binding PDE, AbstractCell md\"\"\" Next, we calculated the notebook's topology , which stored as a `NotebookTopology`. \"\"\" Docs.Binding PDE, NotebookTopology md\"\"\" We calculated the topology by first creating an empty one, and then updating it with all the cells in our notebook. `NotebookTopology`s are always created by updating a previous one. This is done with `updated topology` \"\"\" Docs.Binding PDE, updated topology md\"\"\" info For the initial topology calculation in our example, we passed `notebook` as `notebook cells`, but also as `updated cells`. This tells `updated topology` that all cells are new. \"\"\" md\"\"\" When the notebook is changed later, you can use `updated topology` to calculate a new topology, which will use the old topology as a cache for cells that were not updated. \"\"\" md\"\"\" More API The following API is public, and covered by our semver vesrion numbering. These functions are used by Pluto and can be used by other packages , but might not be fully documented. We currently don't have the capacity https opencollective.com julialang projects juliapluto to document everything, but you can always take a look at Pluto's source for an example of how these functions are used, or you can contact us. \"\"\" md\" More basics\" Docs.Binding PDE, where assigned Docs.Binding PDE, where referenced Docs.Binding PDE, all cells md\" Disabled & resolved\" Docs.Binding PDE, is disabled Docs.Binding PDE, is resolved Docs.Binding PDE, set unresolved md\" Misc\" Docs.Binding PDE, exclude roots Docs.Binding PDE, is soft edge md\" Cell precedence heuristic\" Docs.Binding PDE, cell precedence heuristic Docs.Binding PDE, DEFAULT PRECEDENCE HEURISTIC md\"\"\" Reactivity error types These types are possible value types of the `TopologicalOrder.errable` field. \"\"\" Docs.Binding PDE, ReactivityError Docs.Binding PDE, CyclicReferenceError Docs.Binding PDE, MultipleDefinitionsError md\"\"\" Data structures We defined immutable versions of some core data structures. \"\"\" Docs.Binding PDE, ImmutableDefaultDict Docs.Binding PDE, ImmutableSet Docs.Binding PDE, ImmutableVector Docs.Binding PDE, setdiffkeys Docs.Binding PDE, delete unsafe md\"\"\" ExpressionExplorerExtras These are some things that are too Pluto specific to go into ExpressionExplorer.jl, but are available through PDE as public API in the submodule `ExpressionExplorerExtras`. \"\"\" const EEE PlutoDependencyExplorer.ExpressionExplorerExtras Docs.Binding EEE, ExpressionExplorerExtras Docs.Binding EEE, can be function wrapped Docs.Binding EEE, can macroexpand Docs.Binding EEE, can macroexpand no bind Docs.Binding EEE, collect implicit usings Docs.Binding EEE, maybe macroexpand pluto Docs.Binding EEE, pretransform pluto pkgversion PlutoDependencyExplorer "},{"url":"en/docs/advanced-widgets/","title":"Advanced widgets – overview","tags":["docs","advanced","widgets","AbstractPlutoDingetjes","JavaScript"],"text":" A Pluto.jl notebook v0.19.41 frontmatter title \"Advanced widgets – overview\" date \"2024 04 22\" tags \"docs\", \"advanced\", \"widgets\", \"AbstractPlutoDingetjes\", \"JavaScript\" description \"Pluto provides a framework for advances input and display widgets.\" layout \"docsnotebook.jlmd\" license \"Unlicense\" frontmatter.author name \"Pluto.jl\" url \"https github.com JuliaPluto\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using HypertextLiteral using PlutoUI md\"\"\" Developing advanced widgets for Pluto Pluto has a number of advanced features for developers who want to create complex widgets for Pluto. Let's define some categories Custom inputs widgets that are used with ` bind`, like a slider or a map location picker. Custom outputs for visualising results, like a plot or a map with labels. \"\"\" md\"\"\" Custom input PlutoUI.jl provides some basic inputs, like sliders, textfields and more. But you can also make your own specialised widget For example, you could make a map location picker https github.com lukavdplas PlutoMapPicker.jl , showing a map, and giving back the clicked coordinate with ` bind`. screenshot https github.com lukavdplas PlutoMapPicker.jl raw main screenshot.png chemical equation builder https youtu.be lNbU5jNp67s?t 1546 , giving back a `Catalyst.ReactionSystem` with ` bind`. screenshot https github.com fonsp Pluto.jl assets 6933510 0a27e62f 6ef1 4f13 b47c 2a2cefa8850a widget composed with Markdown and PlutoUI, giving back 4 values in a tuple with ` bind`. screenshot https user images.githubusercontent.com 6933510 145588612 14824654 5c73 45f8 983c 8913c7101a78.png \"\"\" md\"\"\" No JavaScript Composing widgets Some widgets can be written as a combination of existing inputs, and static content like text, styles, layout and images. This means that you can make simple widgets using only Julia and HTML or Markdown, without JavaScript. For this, you can use `PlutoUI.combine` combine `PlutoUI.Experimental.transformed value` transformed value In some cases, you might just want to \"wrap\" and existing widget in static content `PlutoUI.Experimental.wrapped` wrapped Widgets created with these methods can be published in a package \"\"\" Docs.Binding PlutoUI, combine Docs.Binding PlutoUI.Experimental, transformed value Docs.Binding PlutoUI.Experimental, wrapped md\"\"\" Custom inputs with JavaScript The Pluto developers 💖💖💖 love JavaScript And Pluto also provides a first class framework for writing widgets using JavaScript. Preliminary writing JavaScript Before reading further, make sure that you understand the basics of writing JavaScript inside Pluto, and that you know how to debug the web using the DevTools of your favourite browser. Take a look at the featured notebooks https featured.plutojl.org about \"Pluto and the Web\" to learn more. Preliminary `type show htl` Here is the core recipe to use when writing your own widgets 1. Define a type 2. Define a `Base.show` method for HTML 3. Use `HypertextLiteral. htl` to write your widget, using the `io` from `show`. This should be the minimal template for every widget that you write. ```julia import HypertextLiteral htl begin struct MyCoolSlider min Real max Real end function Base.show io IO, m MIME\"text html\", d MyCoolSlider show io, m, htl \"\\\"\" input type range min d.min max d.max \"\"\\\" end end ``` ```julia use it like so bind value MyCoolSlider 5, 10 ``` Let's see it in action \"\"\" import HypertextLiteral htl begin struct MyCoolSlider min Real max Real end function Base.show io IO, m MIME\"text html\", d MyCoolSlider show io, m, htl \"\"\" input type range min d.min max d.max \"\"\" end end bind value MyCoolSlider 5, 10 value md\"\"\" It works Pluto renders your widget by calling the `Base.show` method, and displaying that in the page , it then finds the first element ` input ... ` . Pluto adds an event listener to the `\"input\"` event, and when fired or when first rendered , Pluto takes the `.value` property, sends it to Julia, and it becomes your bound variable. \"\"\" md\"\"\" Core concepts `currentScript`, `value`, input event The widget above `MyCoolSlider` works because the `input` element fires an `\"input\"` event when moved, and it has a `.value` property. This is true for all the built in ` input ... ` elements https developer.mozilla.org en US docs Web HTML Element input . Now... when writing your own inputs, you need to fake it Set the `.value` property from JavaScript, and fire an `\"input\"` event. To select the element, `currentScript` is special API added by Pluto, it refers to the ` script ` element that your code is written in. In the example below, our custom input element is a wrapper ` div `, and we use JavaScript to select it with `currentScript.parentElement`, to set its `value` and to fire the `\"input\"` event. 👉 Can you find this in the code? \"\"\" begin struct RectangleDrawing end function Base.show io IO, m MIME\"text html\", rd RectangleDrawing Base.show io, m, htl \"\"\" div canvas width \"200\" height \"200\" style \"position relative\" canvas script 🐸 `currentScript` is the current script tag we use it to select elements 🐸 const div currentScript.parentElement const canvas div.querySelector \"canvas\" const ctx canvas.getContext \"2d\" var startX 80 var startY 40 function onmove e 🐸 We send the value back to Julia 🐸 div.value e.layerX startX, e.layerY startY div.dispatchEvent new CustomEvent \"input\" ctx.fillStyle ' ffecec' ctx.fillRect 0, 0, 200, 200 ctx.fillStyle ' 3f3d6d' ctx.fillRect startX, startY, ...div.value canvas.onpointerdown e startX e.layerX startY e.layerY canvas.onpointermove onmove canvas.onpointerup e canvas.onpointermove null Fire a fake pointermoveevent to show something onmove layerX 130, layerY 160 script div \"\"\" end end md\"\"\" Try dragging a rectangle in the box below \"\"\" bind dims RectangleDrawing dims area abs prod dims md\"\"\" Custom output Pluto can be used as a framework to have high quality widgets powered by JavaScript, displaying data and calculations from Julia. By creating a Custom output , you can wrap your JavaScript powered widget into a Julia function, such as `plot data `. Techniques used to power Custom Outputs can also be used in Custom Inputs A Custom Input is just a Custom Output with added ` bind` support. DONE ``` currentScript value ``` TODO ``` OBject.definepropeorty div, \"value\", this and id returning DOM element from script invalidation observable API getBoundElementValueLikePluto setBoundElementValueLikePluto getBoundElementEventNameLikePluto getNotebookMetadataExperimental setNotebookMetadataExperimental deleteNotebookMetadataExperimental getCellMetadataExperimental setCellMetadataExperimental deleteCellMetadataExperimental ``` \"\"\" md\"\"\" Core principle a visualiser function with ` htl` TODO \"\"\" md\"\"\" Julia only Layout TODO. See `PlutoUI.ExperimentalLayout` \"\"\" md\"\"\" `AbstractPlutoDingetjes.Display` We recommend reading the docs of `AbstractPlutoDingetjes` https plutojl.org en docs abstractplutodingetjes , containing special API that we offer on top of the Web platform. In particular, I want to highlight two functions for special data needs Use `AbstractPlutoDingetjes.Display.published to js` when visualising a large amount of data using JavaScript, and just interpolating the data into a ` script ` in an `HypertextLiteral. htl` expression is not performant enough. ```julia HypertextLiteral. htl \"\"\\\" script the standard way, fast for small amounts of data let x \\ my vector this is faster for large data let y \\ AbstractPlutoDingetjes.Display.published to js my big vector script \"\\\"\" ``` \"\"\" md\"\"\" `AbstractPlutoDingetjes.Display.with js link` Use `AbstractPlutoDingetjes.Display.with js link` when you want to make on demand requests to Julia from your JavaScript code. \"\"\" md\"\"\" Distributing widgets Once you created a cool widget, the most user friendly way to distribute it is to publish it in a package . You can create a new package with your widget, or you can add it to an existing package. Dependencies When distributing a widget in a package ExampleWidget.jl , you do not need to add Pluto.jl as a dependency to your Project.toml. You just need to add the packages that you used. This could be HypertextLiteral.jl or AbstractPlutoDingetjes.jl. If you used `combine` or another PlutoUI feature, you add PlutoUI.jl as a dependency. HypertextLiteral.jl and especially AbstractPlutoDingetjes.jl are very small dependencies and will not add any noticeable lag to your package installation. Code in notebook or Julia file? When prototyping your widget, you probably want to work fully inside a notebook. Tip when editing the notebook, copy the `localhost` URL and open it in a second window. That way you can see the code and widget side by side. Once you're done, you have two options for moving it to a package. First, you could store your notebook file directly in the package source code. Use the \"Disable in File\" feature to disable cells where you test your widget. https github.com JuliaPluto AbstractPlutoDingetjes.jl assets 6933510 f96980ff 83ce 4b15 8897 dc3e3b1ba72e Second, you could move your code to a classic `.jl` file. Then you could use Revise.jl or ` revise` from PlutoLinks.jl https github.com JuliaPluto PlutoLinks.jl to test it in a notebook while developing the widget. This option might be nicer if your widget has a lot of JavaScript code. Publishing small packages? If you just created one cool widget, you might think \"I want to publish this, but it's too small for a package \". Here is a little political message from fons do it anyways Life is too short to not publish small packages If you made something fun or valuable, you totally deserve to publish it and share it with others. 💛 It's really valuable for others, and a cool experience for you Publishing a widget in a small package is really valuable Others can use it by simply typing `import ExampleWidget` in a notebook . Without publishing it on General, users need to download scripts, copy code, ... This creates lots of hard to reproduce notebooks Once it's on the registry, it's easier for people to discover Especially if the name starts with `Pluto`, like PlutoMapPicker.jl. People searching for your widget can find it online, because registered package show up on juliahub.com and more. It's easy to get feedback, bug reports and contributions from users. And you can easily make patches and release them to your users. Or maybe it was right from the start, and you don't need this \"\"\" import AbstractPlutoDingetjes Docs.Binding AbstractPlutoDingetjes.Display, published to js Docs.Binding AbstractPlutoDingetjes.Display, with js link TableOfContents include definitions true "},{"url":"en/docs/configuration/","title":"⚙️ Configuring Pluto","tags":["docs","introduction"],"text":" A Pluto.jl notebook v0.19.41 frontmatter title \"⚙️ Configuring Pluto\" date \"2024 04 22\" tags \"docs\", \"introduction\" description \"How to change settings of the Pluto.jl Julia notebook\" layout \"docsnotebook.jlmd\" license \"MIT\" frontmatter.author name \"Pluto.jl\" url \"https github.com JuliaPluto\" using Markdown using InteractiveUtils begin import Pkg false && Pkg.activate import Pluto, PlutoUI using HypertextLiteral end md\"\"\" Configuring Pluto In Pluto's design, we always try our best to make choices that work best for our audience, rather than adding more settings. We do this to make Pluto less intimidating to use for newcomers, and to avoid situations where issues are caused by a \"wrong configuration\". However, there are some settings intended for system administrators e.g. running a Pluto server for your students , and for advanced Julia users . These settings are mostly about the \"backend\" everything you don't see . We intentionally don't have settings for the \"frontend\" the GUI interface where you type code and see results . Such settings are usually more difficult to implement and maintain. In some cases, we also want to create a homogenous experience a notebook should look the same on different computers. The best configuration We thought long and hard to find the best default configuration. To get the best Pluto experience, don't change these settings . A custom experience You can achieve a lot of customisability by writing special code Take a look at PlutoLinks.jl https github.com JuliaPluto PlutoLinks.jl , PlutoHooks.jl https github.com JuliaPluto PlutoLinks.jl and AbstractPlutoDingetjes.jl https plutojl.org en docs abstractplutodingetjes . You can also use CSS e.g. with HypertextLiteral.jl https github.com JuliaPluto HypertextLiteral.jl to customise the look of a notebook. \"\"\" md\"\"\" How to use settings Option 1 `Pluto.run kwargs... ` The easiest way to configure Pluto is by providing keyword arguments to `Pluto.run`. For example, to configure the port used to run Pluto ```julia Pluto.run port 1235 ``` \"\"\" md\"\"\" Option 2 `Pluto.ServerSession` You can also create a session first, configure it, and then run a server on that session. ```julia session Pluto.ServerSession session.options.server.auto reload from file true session.options.server.optimize 0 Pluto.run session ``` \"\"\" PlutoUI.TableOfContents include definitions true begin categories CompilerOptions, ServerOptions, SecurityOptions, EvaluationOptions, end md\"\"\" Configuration options Pluto's settings are divided into length categories categories \"\"\" htl \"\"\" ul map categories do c htl \" li a href string \" \", c c a li \" end ul \"\"\" Docs.Binding Pluto.Configuration, categories 1 Docs.Binding Pluto.Configuration, categories 2 Docs.Binding Pluto.Configuration, categories 3 Docs.Binding Pluto.Configuration, categories 4 "},{"url":"en/docs/","title":"🙋 Introduction","tags":["docs","introduction"],"text":"Welcome to Pluto! Welcome to the docs! We are still working on this website ☺️"},{"url":"en/docs/install/","title":"🌼 How to install","tags":["docs","introduction"],"text":"Go to  plutojl.org/#install  for instructions!"},{"url":"en/docs/packages-advanced/","title":"📦 Packages: advanced","tags":["docs","reproducibility"],"text":"Advanced: set up an environment with  Pkg.activate Pluto’s package manager is enabled for all users, for ease of use and to promote reproducibility in scientific computing. There is no option to disable the behaviour  globally  (for your entire Pluto session). Instead, Pluto will detect notebooks that use  Pkg.activate  to set up an environment explicitly, and uses the old behaviour for those notebooks. The philosophy here is that everyone should have a reproducible package environment  by default , without having to do anything. This takes priority over other use cases, and hence  not  using the built-in package manager requires some extra work. Any notebook that calls  Pkg.activate  will not use Pluto’s package management,  and run in ‘backwards compatibility mode’. The  Pkg.activate  call should be placed directly in your notebook code: it is detecting using the same syntax analysis used for reactivity. Pattern: The “global environment” If you do not intend on sharing a notebook file and you want to use your global package environment (called  (v1.6)  or similar, the one you get when you launch the Julia REPL), then you can call  Pkg.activate()  without any arguments. 🙋 If you are developing a package, then activating your global environment is an easy way to test your local version in Pluto. This “global environment” pattern can be placed at the top of a notebook: begin\n    import Pkg\n    # careful: this is _not_ a reproducible environment\n    # activate the global environment\n    Pkg.activate()\n    using Plots, PlutoUI, LinearAlgebra\nend\n When running this in Pluto (try it out!), you will notice that the status marks next to packages disappear, and Pluto is running in ‘backwards compatibility mode’. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself. Pattern: The “shared environment” If you have multiple notebooks in a repository and you want to use share a Pkg environment between them, then you can call  Pkg.activate(path_to_environment) . You can use  @__DIR__  to get the path of the notebook’s folder, and  joinpath(@__DIR__, \"..\")  to get its parent,  joinpath(@__DIR__, \"..\", \"..\")  for the parent’s parent, etc. The function  Base.current_project()  can be used to  automatically  find the closest parent directory that contains a  Project.toml , in most cases this is what you want. For example, if your project looks like this: my_project/\n    data/\n        ...\n    notebooks/\n        Interesting analysis.jl\n        ...\n    Project.toml\n    Manifest.toml\n    ...\n then the “shared environment” pattern can be placed at the top of a notebook: begin\n    import Pkg\n    # activate the shared project environment\n    Pkg.activate(Base.current_project())\n    # instantiate, i.e. make sure that all packages are downloaded\n    Pkg.instantiate()\n    using Plots, PlutoUI, LinearAlgebra\nend\n When running this in Pluto, you will notice that the status marks next to packages disappear, and Pluto is running in ‘backwards compatibility mode’. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself. Pattern: The “Pkg cell” When adding packages, Pluto’s default package management will always install the latest version from the registry. If you need to install a specific version or branch of a package, or a package is not registered, you can use a “Pkg cell”. A common pattern is a so-called “Pkg cell”, placed at the top of a notebook: begin\n    import Pkg\n    # activate a temporary environment\n    Pkg.activate(mktempdir())\n    Pkg.add([\n        Pkg.PackageSpec(name=\"Plots\", version=\"1\"),\n        Pkg.PackageSpec(name=\"PlutoUI\", version=\"0.7\"),\n    ])\n    using Plots, PlutoUI, LinearAlgebra\nend\n This will 1) activate a temporary environment using  Pkg.activate , 2) add the required packages, 3) import them with  using . When running this in Pluto (try it out!), you will notice that the status marks next to packages disappear, and Pluto is running in ‘backwards compatibility mode’. Packages will no longer be installed or removed automatically, you have to use the Pkg REPL to do this yourself. Placing all code in a single  begin  block ensures that the lines will run in the correct order. Advanced: edit the notebook environment Pluto.jl includes a helper function  Pluto.activate_notebook_environment  that activates a notebook Pkg environment in the REPL: julia> import Pluto\n\njulia> Pluto.activate_notebook_environment(\"~/Documents/hello.jl\")\n\njulia> ]\n\n(hello.jl) > status\n After activating a notebook environment, you can use the  Pkg REPL  to view or modify the embedded environment. Changes from either side are synchronised (i.e. Pkg REPL changes are written to the notebook, editing the notebook updates the Pkg REPL env). Watch the demo video:"},{"url":"en/docs/packages/","title":"📦 Packages","tags":["docs","reproducibility"],"text":"Pluto’s built-in  package management Pluto has a  built-in  package manager, which means: 🎈 Packages are  automatically installed  when you use  import  or  using . 🎈 Your package environment is  stored inside the notebook file . When someone else opens your notebook with Pluto, the exact same package environment will be used, and packages will work on their computer. 🙋 These two features are designed to make it easy to write and share  reproducible notebooks . Basic usage Installing and using packages Pluto will automatically install or remove packages while you work on your notebook. When you import a new package, Pluto will install it: 🙋 Most packages will write  installation instructions  in their documentation: like “Run  julia> ] install Example  to install  Example ”. If you are using Pluto, you should  skip these instructions , and import the package directly, using  import Example  or  using Example . Logs Installing packages can take some time, especially when starting Julia for the first time. Click on the status mark next to a package to view the installation progress. You can click on the   icon to view the logs. Removing packages Removing packages is automatic: when you delete code that imports a package, it will be uninstalled from the package environment. It is  recommended  to restart the notebook process afterwards to get a fresh start. Updating packages You can search for and install any available updates by clicking on the   icon. A backup of your notebook file will be created in the same folder as your notebook, in case the new versions do not work as expected. Good to know Based on Pkg Pluto’s package management is a wrapper around  Pkg.jl , Julia’s built-in package manager. Packages are installed from the  General registry . 🙋 You can discover all available packages on  juliahub.com . Isolated package environment Every notebook runs in its own isolated package environment. This ensures that your notebook code will not be influenced by packages installed elsewhere. (The  LOAD_PATH  is set to  [\"@\", \"@stdlib\"] .) Notebook file Pluto stores the contents of  Project.toml  and  Manifest.toml  directly in the notebook file. For forwards-backwards compatibility, this is done using two extra “cells” at the bottom of the file, containing the two files as string literals. For example, here is a notebook that imports  HypertextLiteral  and  PlutoUI :  example file . 🙋 Try it out! Open Pluto, import some packages and look at the notebook file! Fully reproducible environments When someone else opens your notebook for the first time, Pluto will install all required packages based on the information in the  Manifest.toml  file. This means that the exact same versions of all packages you used in the notebook will be installed, ensuring your work is fully reproducible when shared with others. Compatibility across Pluto versions When opening an old Pluto notebook that does not have embedded project files, Pluto will generate them as if you typed those imports for the first time. If a call to  Pkg.activate  is made, the notebook will run in ‘backwards compatibility mode’, using the same environment and behaviour as old Pluto versions. Compatibility across Julia versions The  Manifest.toml  is designed to be (generally)  backwards compatible : you can upgrade Julia and use an old manifest. However, the  Manifest.toml  is not always  forwards compatible : a manifest generated generated with a newer version of Julia might not run on older versions. Pluto will always try to load the embedded manifest, and if it fails, it will  discard the manifest  (leaving only  Project.toml ) and try again. This is one reason why Pluto automatically adds  [compat]  ranges for each package in the  Project.toml . Custom registries Pkg.jl supports additional private or public registries, which can be added in the Julia REPL with  ] registry add https://github.com/myuser/MyRegistry.git , and this is also supported by Pluto’s package managemer. However, note that registries are not stored in the  Project.toml / Manifest.toml  files, which means that other people can only open your notebook if they added the custom registry before doing so. Alternatively, you can use a “Pkg cell” (more on this later) where you add the registry before adding packages. Learn more: advanced Pkg management"},{"url":"en/docs/widgets/javascript/","title":"⚡️ JavaScript for widgets","tags":["blog","advanced","widgets"],"text":" A Pluto.jl notebook v0.18.2 frontmatter title \"⚡️ JavaScript for widgets\" description \"A simple notebook demonstrating the Julia syntax essentials\" layout \"layout.jlhtml\" date \"2020 06 01\" tags \"blog\", \"advanced\", \"widgets\" using Markdown using InteractiveUtils md\" Variables We can define a variable using ` ` assignment . Then we can use its value in other expressions \" x 3 y 2x md\"By default Julia displays the output of the last operation. You can suppress the output by adding ` ` a semicolon at the end. \" md\"We can ask what type a variable has using `typeof` \" typeof y md\" Functions\" md\"We can use a short form, one line function definition for simple functions \" f x 2 x md\"Typing the function's name gives information about the function. To call it we must use parentheses \" f f 10 md\"For longer functions we use the following syntax with the `function` keyword and `end` \" function g x, y z x y return z^2 end g 1, 2 md\" For loops\" md\"Use `for` to loop through a pre determined set of values \" let s 0 for i in 1 10 s i Equivalent to s s i end s end md\"Here, `1 10` is a range representing the numbers from 1 to 10 \" typeof 1 10 md\"Above we used a `let` block to define a new local variable `s`. But blocks of code like this are usually better inside functions, so that they can be reused. For example, we could rewrite the above as follows \" function mysum n s 0 for i in 1 n s i end return s end mysum 100 md\" Conditionals `if`\" md\"We can evaluate whether a condition is true or not by simply writing the condition \" a 3 a 5 md\"We see that conditions have a Boolean `true` or `false` value. We can then use `if` to control what we do based on that value \" if a 5 \"small\" else \"big\" end md\"\"\"Note that the `if` also returns the last value that was evaluated, in this case the string `\"small\"` or `\"big\"`, Since Pluto is reactive, changing the definition of `a` above will automatically cause this to be reevaluated \"\"\" md\" Arrays\" md\" 1D arrays `Vector`s \" md\"We can make a `Vector` 1 dimensional, or 1D array using square brackets \" v 1, 2, 3 typeof v md\"The `1` in the type shows that this is a 1D array. We access elements also using square brackets \" v 2 v 2 10 md\"Note that Pluto does not automatically update cells when you modify elements of an array, but the value does change.\" md\"A nice way to create `Vector`s following a certain pattern is to use an array comprehension \" v2 i^2 for i in 1 10 md\" 2D arrays matrices \" md\"We can make small matrices 2D arrays with square brackets too \" M 1 2 3 4 typeof M md\"The `2` in the type confirms that this is a 2D array.\" md\"This won't work for larger matrices, though. For that we can use e.g.\" zeros 5, 5 md\"Note that `zeros` gives `Float64`s by default. We can also specify a type for the elements \" zeros Int, 4, 5 md\"We can then fill in the values we want by manipulating the elements, e.g. with a `for` loop.\" md\"A nice alternative syntax to create matrices following a certain pattern is an array comprehension with a double `for` loop \" i j for i in 1 5, j in 1 6 md\"\"\" Acknowledgement \"\"\" Markdown.MD Markdown.Admonition \"warning\", \"This notebook is taken from\", md\"\"\" Computational Thinking , a live online Julia Pluto textbook. computationalthinking.mit.edu https computationalthinking.mit.edu , original notebook https github.com mitmath 18S191 blob Fall20 lecture notebooks Basic%20Julia%20syntax.jl \"\"\" using PlutoUI TableOfContents "}]